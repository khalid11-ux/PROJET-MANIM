from manim import *
import numpy as np

config.frame_width = 16
config.frame_height = 9

TITLE_FONT_SIZE = 56
BODY_FONT_SIZE = 36
SMALL_FONT_SIZE = 24

class EuclideanSpaceScene(Scene):
    def construct(self):
        # Couleurs
        primary = ManimColor.from_hex("#58C4DD")
        secondary = ManimColor.from_hex("#FC6255")
        accent = ManimColor.from_hex("#FFD700")
        background = ManimColor.from_hex("#000000")
        foreground = ManimColor.from_hex("#ffffff")
        self.camera.background_color = background

        # --- Nom Khalid Aidoun ---
        name = MathTex(
            r"\mathbb{K}\text{halid}\ \mathbb{A}\text{idoun}",
            font_size=TITLE_FONT_SIZE,
            color=primary
        ).move_to(ORIGIN)
        self.play(Write(name))
        self.wait(1.5)

        # Déplacement du nom en haut à droite
        name_target = MathTex(
            r"\mathbb{K}\text{halid}\ \mathbb{A}\text{idoun}",
            font_size=SMALL_FONT_SIZE,
            color=primary
        )
        name_target.to_edge(UP, buff=0.3)
        name_target.to_edge(RIGHT, buff=0.5)
        self.play(ReplacementTransform(name, name_target))
        self.wait(1)

        # --- 1. Définition d'un espace euclidien ---
        definition = MathTex(
            r"\text{Un espace euclidien } (V, \langle \cdot, \cdot \rangle) \text{ est un espace vectoriel}",
            r"\text{muni d'un produit scalaire } \langle \cdot, \cdot \rangle.",
            color=foreground,
            font_size=BODY_FONT_SIZE
        ).arrange(DOWN, center=True, aligned_edge=LEFT, buff=0.5).move_to(ORIGIN)
        self.play(Write(definition))
        self.wait(2)
        self.play(FadeOut(definition))

        # --- 2. Axes et vecteurs R^2 ---
        axes = Axes(
            x_range=[-4, 4, 1],
            y_range=[-3, 3, 1],
            x_length=7,
            y_length=5,
            axis_config={"color": foreground, "stroke_width": 2, "include_tip": True},
        ).move_to(ORIGIN)
        self.play(Create(axes), run_time=1.1)
        self.wait(0.3)

        # Vecteurs u et v
        u = Arrow(axes.c2p(0,0), axes.c2p(3,1), color=primary, stroke_width=8, buff=0)
        v = Arrow(axes.c2p(0,0), axes.c2p(1,2), color=secondary, stroke_width=8, buff=0)
        u_label = MathTex(r"\vec{u} = \begin{pmatrix}3\\1\end{pmatrix}", color=foreground, font_size=SMALL_FONT_SIZE).next_to(u.get_end(), RIGHT, buff=0.3)
        v_label = MathTex(r"\vec{v} = \begin{pmatrix}1\\2\end{pmatrix}", color=foreground, font_size=SMALL_FONT_SIZE).next_to(v.get_end(), UP, buff=0.3)

        self.play(GrowArrow(u), FadeIn(u_label))
        self.play(GrowArrow(v), FadeIn(v_label))
        self.wait(1)

        # --- 3. Produit scalaire et projection ---
        dot_product = MathTex(
            r"\langle \vec{u}, \vec{v} \rangle = 3\cdot 1 + 1 \cdot 2 = 5",
            color=accent,
            font_size=BODY_FONT_SIZE
        ).to_edge(DOWN, buff=0.5)
        self.play(Write(dot_product))
        self.wait(2)

        # Projection de u sur v
        self.play(FadeOut(dot_product))
        proj_vec = (np.dot([3,1],[1,2])/np.dot([1,2],[1,2])) * np.array([1,2])
        proj = Arrow(axes.c2p(0,0), axes.c2p(proj_vec[0], proj_vec[1]), color=accent, stroke_width=6, buff=0)
        proj_label = MathTex(r"\text{proj}_{\vec{v}} \vec{u}", color=accent, font_size=SMALL_FONT_SIZE).next_to(proj.get_end(), LEFT, buff=0.2)

        self.play(GrowArrow(proj), FadeIn(proj_label))
        self.wait(2)

        # --- 4. Norme d'un vecteur ---
        norm_u = MathTex(
            r"\|\vec{u}\| = \sqrt{3^2 + 1^2} = \sqrt{10}",
            color=foreground,
            font_size=BODY_FONT_SIZE
        ).to_edge(DOWN, buff=0.5)
        self.play(Write(norm_u))
        self.wait(2)
        self.play(FadeOut(norm_u))

        # --- 5. Orthogonalité ---
        self.play(FadeOut(u), FadeOut(v), FadeOut(u_label), FadeOut(v_label), FadeOut(proj), FadeOut(proj_label))
        a = Arrow(axes.c2p(0,0), axes.c2p(2,0), color=primary, stroke_width=8, buff=0)
        b = Arrow(axes.c2p(0,0), axes.c2p(0,2), color=secondary, stroke_width=8, buff=0)
        a_label = MathTex(r"\vec{a}", color=foreground, font_size=SMALL_FONT_SIZE).next_to(a.get_end(), RIGHT, buff=0.2)
        b_label = MathTex(r"\vec{b}", color=foreground, font_size=SMALL_FONT_SIZE).next_to(b.get_end(), UP, buff=0.2)

        self.play(GrowArrow(a), FadeIn(a_label))
        self.play(GrowArrow(b), FadeIn(b_label))
        self.wait(1)

        ortho = MathTex(
            r"\langle \vec{a}, \vec{b} \rangle = 0 \quad \text{(orthogonaux)}",
            color=accent,
            font_size=BODY_FONT_SIZE
        ).to_edge(DOWN, buff=0.5)
        self.play(Write(ortho))
        self.wait(2)
        self.play(FadeOut(ortho), FadeOut(a), FadeOut(b), FadeOut(a_label), FadeOut(b_label), FadeOut(axes))

        # --- 6. Espace euclidien de polynômes ---
        poly_ex = MathTex(
            r"\text{Dans } \mathbb{R}_2[X],\ \langle p, q \rangle = \int_0^1 p(x)q(x) dx",
            color=foreground,
            font_size=BODY_FONT_SIZE
        ).move_to(ORIGIN)
        self.play(Write(poly_ex))
        self.wait(2)
        self.play(FadeOut(poly_ex))

        # --- 7. Espace euclidien des matrices ---
        mat_ex = MathTex(
            r"\text{Dans } M_{2,2}(\mathbb{R}),\ \langle A, B \rangle = \text{Tr}(A^T B)",
            color=foreground,
            font_size=BODY_FONT_SIZE
        ).move_to(ORIGIN)
        self.play(Write(mat_ex))
        self.wait(2)
        self.play(FadeOut(mat_ex))
